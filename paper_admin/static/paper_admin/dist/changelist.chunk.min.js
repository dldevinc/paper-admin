(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["changelist"],{

/***/ "./paper_admin/static/paper_admin/src/js/changelist.js":
/*!*************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/changelist.js ***!
  \*************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var when_dom_ready__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! when-dom-ready */ "./node_modules/when-dom-ready/dist/index.es2015.js");
/* harmony import */ var _components_sortable_table_SortableTable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/sortable_table/SortableTable */ "./paper_admin/static/paper_admin/src/js/components/sortable_table/SortableTable.js");
/* harmony import */ var _components_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/actions */ "./paper_admin/static/paper_admin/src/js/components/actions.js");
/* harmony import */ var _components_RelatedObjectLookups__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/RelatedObjectLookups */ "./paper_admin/static/paper_admin/src/js/components/RelatedObjectLookups.js");
/* harmony import */ var _components_RelatedObjectLookups__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_components_RelatedObjectLookups__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _components_search__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/search */ "./paper_admin/static/paper_admin/src/js/components/search.js");
/* global gettext */




 // Ctrl + Arrows navigation

window.addEventListener('keydown', function (event) {
  if (event.defaultPrevented) {
    return; // Do nothing if the event was already processed
  }

  if (event.ctrlKey) {
    const paperMain = document.getElementById('paper-main');
    const pagination = paperMain.querySelector('.pagination');

    if (!pagination) {
      return;
    }

    switch (event.key) {
      case "Left":
      case "ArrowLeft":
        pagination.querySelector('.page-link[aria-label="Previous"]').click();
        break;

      case "Right":
      case "ArrowRight":
        pagination.querySelector('.page-link[aria-label="Next"]').click();
        break;

      default:
        // Quit when this doesn't handle the key event.
        return;
    } // Cancel the default action to avoid it being handled twice


    event.preventDefault();
  }
});
Object(when_dom_ready__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  const table = document.getElementById('result_list');

  if (table && table.classList.contains('table-sortable')) {
    if (table.classList.contains('table-sortable-allowed')) {
      new _components_sortable_table_SortableTable__WEBPACK_IMPORTED_MODULE_1__["default"](table, {
        url: table.dataset.orderUrl,
        tree: table.classList.contains('table-mptt'),
        handler: '.sort-handler'
      });
    } else {
      $(table).find('.sort-handler').tooltip({
        title: gettext('Sort list by this column to enable ordering'),
        placement: 'bottom',
        trigger: 'hover',
        html: true,
        delay: {
          show: 300,
          hide: 100
        }
      });
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery-exposed.js")))

/***/ }),

/***/ "./paper_admin/static/paper_admin/src/js/components/RelatedObjectLookups.js":
/*!**********************************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/components/RelatedObjectLookups.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {// Handles related-objects functionality: lookup link for raw_id_fields
// and Add Another links.
(function ($) {
  'use strict'; // IE doesn't accept periods or dashes in the window name, but the element IDs
  // we use to generate popup window names may contain them, therefore we map them
  // to allowed characters in a reversible way so that we can locate the correct
  // element when the popup window is dismissed.

  function id_to_windowname(text) {
    text = text.replace(/\./g, '__dot__');
    text = text.replace(/-/g, '__dash__');
    return text;
  }

  function windowname_to_id(text) {
    text = text.replace(/__dot__/g, '.');
    text = text.replace(/__dash__/g, '-');
    return text;
  }

  function showAdminPopup(triggeringLink, name_regexp, add_popup) {
    let name = triggeringLink.id.replace(name_regexp, '');
    name = id_to_windowname(name);
    let href = triggeringLink.href;

    if (add_popup) {
      if (href.indexOf('?') === -1) {
        href += '?_popup=1';
      } else {
        href += '&_popup=1';
      }
    } // Центрирование popup


    const browser_left = typeof window.screenX !== 'undefined' ? window.screenX : window.screenLeft,
          browser_top = typeof window.screenY !== 'undefined' ? window.screenY : window.screenTop,
          browser_width = typeof window.outerWidth !== 'undefined' ? window.outerWidth : document.body.clientWidth,
          browser_height = typeof window.outerHeight !== 'undefined' ? window.outerHeight : document.body.clientHeight,
          popup_width = 940,
          popup_height = 600,
          top_position = browser_top + Math.round((browser_height - popup_height) / 2),
          left_position = browser_left + Math.round((browser_width - popup_width) / 2);
    const win = window.open(href, name, 'width=' + popup_width + ',height=' + popup_height + ',top=' + top_position + ',left=' + left_position + ',resizable=yes,scrollbars=yes');
    win.focus();
    return false;
  }

  function showRelatedObjectLookupPopup(triggeringLink) {
    return showAdminPopup(triggeringLink, /^lookup_/, true);
  }

  function dismissRelatedLookupPopup(win, chosenId) {
    const name = windowname_to_id(win.name);
    const elem = document.getElementById(name);

    if (elem.className.indexOf('vManyToManyRawIdAdminField') !== -1 && elem.value) {
      elem.value += ',' + chosenId;
    } else {
      document.getElementById(name).value = chosenId;
    }

    win.close();
  }

  function showRelatedObjectPopup(triggeringLink) {
    return showAdminPopup(triggeringLink, /^(change|add|delete)_/, false);
  }

  function updateRelatedObjectLinks(triggeringLink) {
    const $this = $(triggeringLink);
    const siblings = $this.closest('.related-widget-wrapper').find('.view-related, .change-related, .delete-related');

    if (!siblings.length) {
      return;
    }

    const value = $this.val();

    if (value) {
      siblings.each(function () {
        const elm = $(this);
        elm.attr('href', elm.attr('data-href-template').replace('__fk__', value));
      });
    } else {
      siblings.removeAttr('href');
    }
  }

  function dismissAddRelatedObjectPopup(win, newId, newRepr) {
    const name = windowname_to_id(win.name);
    const elem = document.getElementById(name);

    if (elem) {
      const elemName = elem.nodeName.toUpperCase();

      if (elemName === 'SELECT') {
        elem.options[elem.options.length] = new Option(newRepr, newId, true, true);
      } else if (elemName === 'INPUT') {
        if (elem.className.indexOf('vManyToManyRawIdAdminField') !== -1 && elem.value) {
          elem.value += ',' + newId;
        } else {
          elem.value = newId;
        }
      } // Trigger a change event to update related links if required.


      $(elem).trigger('change');
    }

    win.close();
  }

  function dismissChangeRelatedObjectPopup(win, objId, newRepr, newId) {
    const id = windowname_to_id(win.name).replace(/^edit_/, '');
    const select = $('#' + id);
    select.find('option').each(function () {
      if (this.value === objId) {
        this.textContent = newRepr;
        this.value = newId;
      }
    });
    win.close();
  }

  function dismissDeleteRelatedObjectPopup(win, objId) {
    const id = windowname_to_id(win.name).replace(/^delete_/, '');
    const select = $('#' + id);
    select.find('option').each(function () {
      if (this.value === objId) {
        $(this).remove();
      }
    }).trigger('change');
    win.close();
  } // Global for testing purposes


  window.id_to_windowname = id_to_windowname;
  window.windowname_to_id = windowname_to_id;
  window.showRelatedObjectLookupPopup = showRelatedObjectLookupPopup;
  window.dismissRelatedLookupPopup = dismissRelatedLookupPopup;
  window.showRelatedObjectPopup = showRelatedObjectPopup;
  window.updateRelatedObjectLinks = updateRelatedObjectLinks;
  window.dismissAddRelatedObjectPopup = dismissAddRelatedObjectPopup;
  window.dismissChangeRelatedObjectPopup = dismissChangeRelatedObjectPopup;
  window.dismissDeleteRelatedObjectPopup = dismissDeleteRelatedObjectPopup; // Kept for backward compatibility

  window.showAddAnotherPopup = showRelatedObjectPopup;
  window.dismissAddAnotherPopup = dismissAddRelatedObjectPopup;
  $(document).ready(function () {
    $("a[data-popup-opener]").on('click', function (event) {
      event.preventDefault();
      opener.dismissRelatedLookupPopup(window, $(this).data("popup-opener"));
    });
    $('body').on('click', '.related-widget-wrapper-link', function (e) {
      e.preventDefault();

      if (this.href) {
        const event = $.Event('django:show-related', {
          href: this.href
        });
        $(this).trigger(event);

        if (!event.isDefaultPrevented()) {
          showRelatedObjectPopup(this);
        }
      }
    }).on('change', '.related-widget-wrapper select', function () {
      const event = $.Event('django:update-related');
      $(this).trigger(event);

      if (!event.isDefaultPrevented()) {
        updateRelatedObjectLinks(this);
      }
    }).on('change', '.related-widget-wrapper input', function () {
      if (this.checked) {
        updateRelatedObjectLinks(this);
      }
    }).on('click', '.related-lookup', function (e) {
      e.preventDefault();
      const event = $.Event('django:lookup-related');
      $(this).trigger(event);

      if (!event.isDefaultPrevented()) {
        showRelatedObjectLookupPopup(this);
      }
    });
    $('.related-widget-wrapper select').trigger('change');
    $('.related-widget-wrapper input:checked').trigger('change');
  });
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery-exposed.js")))

/***/ }),

/***/ "./paper_admin/static/paper_admin/src/js/components/actions.js":
/*!*********************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/components/actions.js ***!
  \*********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var when_dom_ready__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! when-dom-ready */ "./node_modules/when-dom-ready/dist/index.es2015.js");
/*global gettext, interpolate, ngettext*/

const TOGGLE_ALL_ID = 'action-toggle';
const CHECKBOX_CLASS = 'action-select';
const CHECKBOX_LABEL_SELECTOR = '.action-checkbox .vCustomCheckbox';
const COUNTER_CLASS = 'action-counter';
const QUESTION_CLASS = 'action-question';
const ALL_CLASS = 'action-all';
const ACROSS_CLASS = 'select-across';
const CLEAR_CLASS = 'action-clear';
Object(when_dom_ready__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  const checkboxes = document.querySelectorAll(`.${CHECKBOX_CLASS}`);

  if (checkboxes.length) {
    initActions(Array.from(checkboxes));
  }
});

function initActions(inputs) {
  let lastChecked = null;
  const table = document.getElementById('result_list');
  const allToggleInput = document.getElementById(TOGGLE_ALL_ID); // клик на чекбокс "выбрать все"

  allToggleInput.addEventListener('change', function () {
    const rows = inputs.map(input => input.closest('tr'));
    toggleRows(rows, this.checked);
    updateCounter(inputs);
  }); // пользовательское событие выделения ряда таблицы

  table.addEventListener('select', function (event) {
    const target = event.target;

    if (target.tagName !== 'TR' || target.closest('table') !== table) {
      return;
    }

    const state = Boolean(event.detail.state);
    const checkbox = target.querySelector(`.${CHECKBOX_CLASS}`);
    checkbox.checked = state;
    target.classList.toggle('selected', state); // все ли чекбоксы выделены

    allToggleInput.checked = inputs.find(input => !input.checked) == null;
  });
  table.addEventListener('click', function (event) {
    const target = event.target;
    const row = target.closest('tr');
    const label_clicked = target.closest(CHECKBOX_LABEL_SELECTOR);
    const checkbox_label = row && row.querySelector(CHECKBOX_LABEL_SELECTOR);
    const checkbox = checkbox_label && checkbox_label.querySelector(`.${CHECKBOX_CLASS}`); // клик вне строк таблицы

    if (!row) {
      return;
    } // отмена выделения чекбокса при клике на <label>


    if (label_clicked) {
      event.preventDefault();
    }

    if (event.shiftKey && lastChecked && lastChecked !== checkbox) {
      // массовое выделение (через Shift)
      const lastIndex = inputs.indexOf(lastChecked);
      const targetIndex = inputs.indexOf(checkbox);
      const startIndex = Math.min(lastIndex, targetIndex);
      const endIndex = Math.max(lastIndex, targetIndex);
      const input_slice = inputs.slice(startIndex, endIndex + 1);
      const rows = input_slice.map(input => input.closest('tr'));
      toggleRows(rows, lastChecked.checked);
    } else if (label_clicked || event.ctrlKey && !event.shiftKey) {
      // клик на чекбокс или на строку через Ctrl
      lastChecked = checkbox;
      toggleRows([row], !checkbox.checked);
    }

    updateCounter(inputs);
  }); // отмена выделения текста при клике с удержанным Shift

  table.addEventListener('mousedown', function (event) {
    const target = event.target;

    if (event.shiftKey && (target.tagName === 'TD' || target.tagName === 'TH')) {
      event.preventDefault();
    }
  }); // выбор всех записей таблицы

  document.addEventListener('click', function (event) {
    const target = event.target;

    if (target.tagName === 'A' && target.closest(`.${QUESTION_CLASS}`)) {
      event.preventDefault();
      selectAcross();
    }
  }); // очистка выбора

  document.addEventListener('click', function (event) {
    const target = event.target;

    if (target.tagName === 'A' && target.closest(`.${CLEAR_CLASS}`)) {
      event.preventDefault();
      allToggleInput.checked = false;
      const rows = inputs.map(input => input.closest('tr'));
      toggleRows(rows, false);
      clearAcross(inputs);
      updateCounter(inputs);
    }
  });
  protectEditForm();
}
/**
 * Требование подтверждения выполнения действия, если в форме были изменения.
 */


function protectEditForm() {
  let list_editable_changed = false;
  const form = document.getElementById('changelist_form');
  form.addEventListener('change', function (event) {
    const target = event.target;

    if (target.tagName === 'INPUT') {
      if (target.closest(`.${CHECKBOX_CLASS}`) || target.id === TOGGLE_ALL_ID) {// nothing
      } else {
        list_editable_changed = true;
      }
    } else if (target.tagName === 'SELECT') {
      if (target.closest(`.action-action`)) {// nothing
      } else {
        list_editable_changed = true;
      }
    } else {
      list_editable_changed = true;
    }
  });
  form.addEventListener('click', function (event) {
    const target = event.target;
    const action_button = target.closest('[name="index"]');

    if (action_button && list_editable_changed) {
      const agree = confirm(gettext("You have unsaved changes on individual editable fields. If you run an action, your unsaved changes will be lost."));

      if (!agree) {
        event.preventDefault();
      }
    }
  });
  form.addEventListener('click', function (event) {
    const target = event.target;
    const save_button = target.closest('[name="_save"]');
    const action_selects = document.querySelectorAll('.actions select[name="action"]');
    const action_changed = !Array.prototype.every.call(action_selects, function (select) {
      return !select.value;
    });

    if (save_button && action_changed) {
      let apply;

      if (list_editable_changed) {
        apply = confirm(gettext("You have selected an action, but you haven't saved your changes to individual fields yet. Please click OK to save. You'll need to re-run the action."));
      } else {
        apply = confirm(gettext("You have selected an action, and you haven't made any changes on individual fields. You're probably looking for the Go button rather than the Save button."));
      }

      if (!apply) {
        event.preventDefault();
      }
    }
  });
}
/**
 * Установка/сброс галочки в чекбоксах.
 * @param {HTMLTableRowElement[]} rows
 * @param {Boolean} checked
 */


function toggleRows(rows, checked) {
  rows.forEach(function (row) {
    if (row && row.tagName === 'TR') {
      row.dispatchEvent(new CustomEvent('select', {
        bubbles: true,
        cancelable: true,
        detail: {
          state: checked
        }
      }));
    }
  });
}

function updateCounter(inputs) {
  const selected = inputs.reduce((sum, input) => sum + (input.checked ? 1 : 0), 0);
  const counters = document.querySelectorAll(`.${COUNTER_CLASS}`);
  counters.forEach(function (counter) {
    counter.innerHTML = interpolate(ngettext('%(sel)s of %(cnt)s selected', '%(sel)s of %(cnt)s selected', selected), {
      sel: selected,
      cnt: counter.dataset.actionsIcnt
    }, true);
  });

  if (selected === inputs.length) {
    showQuestion();
  } else {
    clearAcross(inputs);
  }
}
/**
 * Показ ссылки "выбрать всё"
 */


function showQuestion() {
  const question = document.querySelector(`.${QUESTION_CLASS}`);
  question && (question.hidden = false);
}
/**
 * Установка значения input-элементу для выполнения действия над всеми элементами
 * @param {Boolean} value
 */


function setAcrossInput(value) {
  const acrossInput = document.querySelectorAll(`.${ACROSS_CLASS}`);
  acrossInput.forEach(function (input) {
    input.value = Number(value);
  });
}

function selectAcross() {
  setAcrossInput(true);
  const counter = document.querySelector(`.${COUNTER_CLASS}`);
  counter && (counter.hidden = true);
  const allContainer = document.querySelector(`.${ALL_CLASS}`);
  allContainer && (allContainer.hidden = false);
  const question = document.querySelector(`.${QUESTION_CLASS}`);
  question && (question.hidden = true);
  const clear = document.querySelector(`.${CLEAR_CLASS}`);
  clear && (clear.hidden = false);
}

function clearAcross(inputs) {
  setAcrossInput(false);
  const counter = document.querySelector(`.${COUNTER_CLASS}`);
  counter && (counter.hidden = false);
  const allContainer = document.querySelector(`.${ALL_CLASS}`);
  allContainer && (allContainer.hidden = true);
  const selected = inputs.reduce((sum, input) => sum + (input.checked ? 1 : 0), 0);
  const question = document.querySelector(`.${QUESTION_CLASS}`);
  question && (question.hidden = selected !== inputs.length);
  const clear = document.querySelector(`.${CLEAR_CLASS}`);
  clear && (clear.hidden = true);
}

/***/ }),

/***/ "./paper_admin/static/paper_admin/src/js/components/search.js":
/*!********************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/components/search.js ***!
  \********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var when_dom_ready__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! when-dom-ready */ "./node_modules/when-dom-ready/dist/index.es2015.js");

Object(when_dom_ready__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  const form = document.querySelector('.paper-search-form');
  const input = form && form.querySelector('.form-control');
  input && input.addEventListener('focus', function () {
    this.select();
  });
});

/***/ }),

/***/ "./paper_admin/static/paper_admin/src/js/components/sortable_table/ListTree.js":
/*!*************************************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/components/sortable_table/ListTree.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Представление списка DOM-элементов в виде дерева.
 * Каждый DOM-элемент должен иметь data-атрибуты: id, parent.
 * Каждый дочерний узел должен идти после родителя.
 * @module ListTree
 */

/**
 * @typedef {Object} module:ListTree.ListTreeNode
 * @property {Number}       pk
 * @property {Number}       parent
 * @property {HTMLElement}  element
 * @property {Number[]}     childs
 */

/**
 * Конструктор объектов ListTree.
 * @param {NodeList|Element[]} elements
 * @constructor
 */
function ListTree(elements) {
  this._buildTree(elements);
}
/**
 * Создание узла дерева.
 * @param {HTMLElement} child
 * @returns {module:ListTree.ListTreeNode}
 * @private
 */


ListTree.prototype._createNode = function (child) {
  const dataset = child.dataset;
  return {
    pk: parseInt(dataset.id),
    parent: parseInt(dataset.parent),
    element: child,
    childs: []
  };
};
/**
 * Добавление узла дерева в карту, для быстрого поиска по ID.
 * @param {module:ListTree.ListTreeNode} node
 * @returns {Boolean}
 * @private
 */


ListTree.prototype._addNode = function (node) {
  if (node && typeof node.pk === 'number') {
    this._nodes[node.pk] = node;

    if (isNaN(node.parent)) {
      this._roots.push(node);
    }

    return true;
  }

  return false;
};
/**
 * Получение узла по ID.
 * @param {Number} pk
 * @returns {module:ListTree.ListTreeNode}
 */


ListTree.prototype.getNode = function (pk) {
  if (this._nodes === null) {
    throw new Error('tree is empty');
  }

  if (!(pk in this._nodes)) {
    throw new Error(`node ${pk} not found`);
  }

  return this._nodes[pk];
};
/**
 * Построение дерева из элементов.
 * @param {Element[]} elements
 * @private
 */


ListTree.prototype._buildTree = function (elements) {
  const stack = [];
  this._nodes = {};
  this._roots = [];
  elements.forEach(function (elem) {
    let node = this._createNode(elem);

    this._addNode(node);

    while (stack.length) {
      let stack_node = stack[0];

      if (node.parent === stack_node.pk) {
        stack_node.childs.push(node.pk);
        stack.unshift(node);
        return;
      }

      stack.shift();
    }

    stack.unshift(node);
  }.bind(this));
};
/**
 * Получение корневых элементов.
 * @returns {Element[]}
 */


ListTree.prototype.getRoots = function () {
  if (this._roots === null) {
    throw new Error('tree is empty');
  }

  return this._roots.map(function (root_node) {
    return root_node.element;
  }.bind(this));
};
/**
 * Получение всех потомков узла.
 * @param {Number} pk
 * @returns {Element[]}
 */


ListTree.prototype.getDescendants = function (pk) {
  const node = this.getNode(pk);
  return node.childs.reduce(function (result, child_pk) {
    let child_node = this.getNode(child_pk);

    if (child_node) {
      result.push(child_node.element);
      result = result.concat(this.getDescendants(child_pk));
    }

    return result;
  }.bind(this), []);
};

/* harmony default export */ __webpack_exports__["default"] = (ListTree);

/***/ }),

/***/ "./paper_admin/static/paper_admin/src/js/components/sortable_table/SortableTable.js":
/*!******************************************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/components/sortable_table/SortableTable.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.complete.esm.js");
/* harmony import */ var _ListTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ListTree */ "./paper_admin/static/paper_admin/src/js/components/sortable_table/ListTree.js");
/* harmony import */ var _StaggerHighlight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StaggerHighlight */ "./paper_admin/static/paper_admin/src/js/components/sortable_table/StaggerHighlight.js");
/**
 * Таблица с возможностью сортировки строк.
 * Каждая строка должна иметь атрибут data-id.
 * В случае, если строки представляют дерево, то еще необходим атрибут data-parent.
 * @module SortableTable
 */

/**
 * @typedef {Object} module:SortableTable.SortableTableOptions
 * @property {String}  url
 * @property {Boolean} [tree]
 * @property {String}  [handler]
 * @property {String}  [disabledClass]
 */



/**
 * Конструктор объектов SortableTable.
 * @param {Element} table
 * @param {module:SortableTable.SortableTableOptions} [options]
 * @constructor
 */

function SortableTable(table, options) {
  /** @type {module:SortableTable.SortableTableOptions} */
  this.opts = Object.assign({
    url: null,
    tree: false,
    handler: '.handler',
    disabledClass: 'disabled'
  }, options);
  /** @type {Element} */

  this.table = table;
  /** @type {Element} */

  this.tbody = table.querySelector('tbody');

  if (!this.tbody) {
    throw new Error('table body not found');
  }
  /** @type {?ListTree} */


  this.tree = null;

  this._createSortable();
}
/**
 * Инициализация плагина сортировки.
 * @private
 */


SortableTable.prototype._createSortable = function () {
  return sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.tbody, {
    animation: 0,
    draggable: 'tr',
    handle: this.opts.handler,
    filter: '.' + this.opts.disabledClass,
    ghostClass: 'sortable-ghost',
    onStart: this._onStart.bind(this),
    onMove: this._onMove.bind(this),
    onEnd: this._onEnd.bind(this)
  });
};
/**
 * Обработчик события начала перетаскивания.
 * @param evt
 * @private
 */


SortableTable.prototype._onStart = function (evt) {
  const rows = this.tbody.querySelectorAll('tr');

  if (this.opts.tree) {
    this.tree = new _ListTree__WEBPACK_IMPORTED_MODULE_1__["default"](rows);
  } // блокируем все узлы, кроме соседних


  const item_parentId = parseInt(evt.item.dataset.parent);
  rows.forEach(function (row) {
    const parentId = parseInt(row.dataset.parent);

    if ((!isNaN(parentId) || !isNaN(item_parentId)) && parentId !== item_parentId) {
      row.classList.add(this.opts.disabledClass);
    }
  }.bind(this));
};
/**
 * Обработчик события перетаскивания.
 * @param evt
 * @returns {Boolean}
 * @private
 */


SortableTable.prototype._onMove = function (evt) {
  return !evt.related.classList.contains(this.opts.disabledClass);
};
/**
 * Обработчик события завершения перетаскивания.
 * @param evt
 * @private
 */


SortableTable.prototype._onEnd = function (evt) {
  // снимаем блокировку со всех узлов
  const rows = this.tbody.querySelectorAll('tr');
  rows.forEach(function (row) {
    row.classList.remove(this.opts.disabledClass);
  }.bind(this));

  let moved = this._getMovedRows(evt);

  if (!moved.length) {
    return;
  }

  this._normalizeTable(evt, moved);

  const map = this._createOrderMap(evt, moved); // выделение рядов, учавствовавших в перемещении


  const highlighter = new _StaggerHighlight__WEBPACK_IMPORTED_MODULE_2__["default"](moved);

  this._sendRequest(map).then(function () {
    highlighter.release();
  });
};
/**
 * Получение строк, чей порядок изменился.
 * @param evt
 * @returns {Element[]}
 * @private
 */


SortableTable.prototype._getMovedRows = function (evt) {
  const sliceStart = Math.min(evt.oldIndex, evt.newIndex);
  const sliceEnd = Math.max(evt.oldIndex, evt.newIndex);
  const rows = this.tbody.querySelectorAll('tr');
  let slice = Array.prototype.slice.call(rows, sliceStart, sliceEnd + 1);

  if (this.tree) {
    // пропускаем узлы, не являющиеся соседними
    const pk = parseInt(evt.item.dataset.id);
    const node = this.tree.getNode(pk);
    slice = slice.filter(function (row) {
      return parseInt(row.dataset.parent) === node.parent;
    });
  }

  return slice;
};
/**
 * Создание карты новых значений сортировки строк.
 * @param evt
 * @param {Element[]} rows
 * @returns {Object}
 * @private
 */


SortableTable.prototype._createOrderMap = function (evt, rows) {
  const pk_array = [];
  const order_array = [];
  rows.forEach(function (row) {
    const handle = row.querySelector(this.opts.handler);

    if (handle) {
      pk_array.push(parseInt(row.dataset.id));
      order_array.push(parseInt(handle.dataset.order));
    }
  }.bind(this)); // циклический сдвиг значений order

  const movedDown = evt.oldIndex < evt.newIndex;

  if (movedDown) {
    order_array.unshift(order_array.pop());
  } else {
    order_array.push(order_array.shift());
  }

  return pk_array.reduce(function (result, pk, i) {
    result[pk] = order_array[i]; // обновляем атрибут order

    const row = this.tbody.querySelector('tr[data-id="' + pk + '"]');
    row.querySelector(this.opts.handler).setAttribute('data-order', order_array[i]);
    return result;
  }.bind(this), {});
};
/**
 * Нормализация таблицы.
 * Все дочерние строки перемещаются под своего родителя.
 * Без этого метода может случиться ситуация, когда элемент
 * был перемещен между своим соседом и его детьми.
 * @param evt
 * @param {Element[]} moved
 * @private
 */


SortableTable.prototype._normalizeTable = function (evt, moved) {
  if (this.tree) {
    const pk = parseInt(evt.item.dataset.id);
    const node = this.tree.getNode(pk);
    const prev = evt.item.previousElementSibling;
    const next = evt.item.nextElementSibling;
    const parents = moved.slice();

    if (prev && next) {
      // если предыдущая строка - сосед, а следующая - ребенок соседа,
      // то сосед должен быть в списке нормализации.
      const isPrevSibling = parseInt(prev.dataset.parent) === node.parent;
      const isNextChild = parseInt(next.dataset.parent) === parseInt(prev.dataset.id);

      if (isPrevSibling && isNextChild && parents.indexOf(prev) < 0) {
        parents.unshift(prev);
      }
    } // перенос детей под родителя


    parents.forEach(function (parent) {
      const pk = parseInt(parent.dataset.id);
      const childs = this.tree.getDescendants(pk);
      Element.prototype.after.apply(parent, childs);
    }.bind(this));
  }
};
/**
 * Отправка новых значений сортировки на сервер.
 * @param {Object} data
 * @returns {Promise<Response>}
 * @private
 */


SortableTable.prototype._sendRequest = function (data) {
  return fetch(this.opts.url, {
    method: 'POST',
    credentials: 'same-origin',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  }).then(function (response) {
    if (!response.ok) {
      const error = new Error(`${response.status} ${response.statusText}`);
      error.response = response;
      throw error;
    }
  });
};

/* harmony default export */ __webpack_exports__["default"] = (SortableTable);

/***/ }),

/***/ "./paper_admin/static/paper_admin/src/js/components/sortable_table/StaggerHighlight.js":
/*!*********************************************************************************************!*\
  !*** ./paper_admin/static/paper_admin/src/js/components/sortable_table/StaggerHighlight.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Прелоадер для списков / таблиц.
 * Последовательно добавляет класс DOM-элементам и удаляет этот класс,
 * когда выполняется последнее событие из:
 * a) всем элементам был добавлен класс
 * b) вызван метод release()
 * @module StaggerHighlight
 */

/**
 * @typedef {Object} module:StaggerHighlight.StaggerHighlightOptions
 * @property {String} className
 * @property {Number} staggerMin
 * @property {Number} staggerMax
 */

/**
 * Конструктор объектов StaggerHighlight.
 * @param {Element[]} elements
 * @param {module:StaggerHighlight.StaggerHighlightOptions} [options]
 * @constructor
 */
function StaggerHighlight(elements, options) {
  /** @type module:StaggerHighlight.StaggerHighlightOptions */
  this.opts = Object.assign({
    className: 'highlight',
    staggerMin: 12,
    staggerMax: 50
  }, options);
  /**
   * @type {Element[]}
   * @private
   */

  this._elements = elements;
  /**
   * @type {Boolean}
   * @private
   */

  this._isReleased = false;
  /**
   * @type {?Number}
   * @private
   */

  this._timer = this._createTimer();
}
/**
 * Создание таймера, выделяюего элементы один за другим.
 * @returns {Number}
 * @private
 */


StaggerHighlight.prototype._createTimer = function () {
  let i = 0;
  const count = this._elements.length;
  const speed = Math.max(this.opts.staggerMin, this.staggerMax * 2 / count);
  return setInterval(function () {
    if (i < count) {
      this._elements[i].classList.add(this.opts.className);

      i++;
    } else {
      this._destroyTimer();

      if (this._isReleased) {
        this._removeClass();
      }
    }
  }.bind(this), speed);
};
/**
 * Уничтожение таймера.
 * @private
 */


StaggerHighlight.prototype._destroyTimer = function () {
  if (this._timer !== null) {
    clearInterval(this._timer);
    this._timer = null;
  }
};
/**
 * Немедленное удаление класса со всех элементов.
 * @private
 */


StaggerHighlight.prototype._removeClass = function () {
  this._elements.forEach(function (node) {
    node.classList.remove(this.opts.className);
  }.bind(this));
};
/**
 * Сигнал завершения операции.
 */


StaggerHighlight.prototype.release = function () {
  this._isReleased = true;

  if (this._timer === null) {
    this._removeClass();
  }
};

/* harmony default export */ __webpack_exports__["default"] = (StaggerHighlight);

/***/ })

}]);
//# sourceMappingURL=changelist.chunk.min.js.map